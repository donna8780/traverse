# Traverse

<p align="center">
<img src="https://github.com/user-attachments/assets/ba9fe018-a399-4b50-bfbc-36b761f90f18" width="20%" height="30%">

## 웹 개발팀 

* 개발 기간 : 2024.07~2024.09 (약 6주)
* 개발 인원 : 5명


## 프로젝트 소개

### 국내 여행지 추천 및 일정 계획 사이트

지도 API를 활용하여 사용자는 지도 상에서 직관적으로 여행지를 탐색할 수 있으며, 투어 API를 통해 각 장소의 상세 정보와 추천 명소를 실시간으로 확인할 수 있습니다.
또한, 사용자의 선호도와 여행 스타일을 반영한 맞춤형 여행지 추천 알고리즘이 적용되어, 개인화된 여행지 목록을 제공합니다. 사용자는 이를 기반으로 쉽게 일정을 구성하고, 추가적인 여행 정보를 받아볼 수 있습니다.
여행지 정보뿐만 아니라, 숙박, 맛집, 관광지 등을 한눈에 확인할 수 있어 더욱 편리한 여행 계획 수립이 가능하도록 설계하였습니다.

## Stacks 🐈

|제목|내용|
|------|---|
|Language|<img src="https://img.shields.io/badge/java-007396?style=for-the-badge&logo=java&logoColor=white"> <img src="https://img.shields.io/badge/html5-E34F26?style=for-the-badge&logo=html5&logoColor=white"> <img src="https://img.shields.io/badge/javascript-F7DF1E?style=for-the-badge&logo=javascript&logoColor=black"> <img src="https://img.shields.io/badge/css-1572B6?style=for-the-badge&logo=css3&logoColor=white"> |
|Frame Work|<img src="https://img.shields.io/badge/springboot-6DB33F?style=for-the-badge&logo=springboot&logoColor=white"> |
|Build Tool|<img src="https://img.shields.io/badge/gradle-02303A?style=for-the-badge&logo=gradle&logoColor=white">|
|Database|<img src="https://img.shields.io/badge/mysql-4479A1.svg?style=for-the-badge&logo=mysql&logoColor=white">|
|Frontend|<img src="https://img.shields.io/badge/html5-E34F26?style=for-the-badge&logo=html5&logoColor=white"> <img src="https://img.shields.io/badge/css-1572B6?style=for-the-badge&logo=css3&logoColor=white"> <img src="https://img.shields.io/badge/javascript-F7DF1E?style=for-the-badge&logo=javascript&logoColor=black">|
|Library|<img src="https://img.shields.io/badge/Thymeleaf-%23005C0F.svg?style=for-the-badge&logo=Thymeleaf&logoColor=white">,<img src="https://img.shields.io/badge/bootstrap-%238511FA.svg?style=for-the-badge&logo=bootstrap&logoColor=white">|
|Server|<img src="https://img.shields.io/badge/amazonaws-232F3E?style=for-the-badge&logo=amazonaws&logoColor=white"><img src="https://img.shields.io/badge/apache%20tomcat-%23F8DC75.svg?style=for-the-badge&logo=apache-tomcat&logoColor=black">|
|Version Control|<img src="https://img.shields.io/badge/github-181717?style=for-the-badge&logo=github&logoColor=white">|
|Social|<img src="https://img.shields.io/badge/Discord-%235865F2.svg?style=for-the-badge&logo=discord&logoColor=white">|

## 화면 구성 📺

### 0. 메인페이지

실시간 날씨 정보 확인 및 지역별 지도 클릭이 가능합니다.

<p align="center">
<img src="https://github.com/user-attachments/assets/9899c60f-b674-42f9-baf4-c09bda4432c9" width="30%">
<img src="https://github.com/user-attachments/assets/3cae7909-6dec-4cac-9127-258375b32aab" width="30%">
<img src="https://github.com/user-attachments/assets/61117121-f5f2-4b7e-bd4e-8ca8303bda8f" width="30%">
</p>

### 1. 로그인/회원가입

사용자는 로그인 및 회원가입을 할 수 있습니다.

<p align="center">
<img src="https://github.com/user-attachments/assets/e39b9058-b45f-4c89-bc58-c76bde2282f1" width="40%">

### 2. 마이페이지

프로필 등록 및 수정, 탈퇴 기능을 제공하며, 본인의 여행 후기를 확인할 수 있습니다.

<p align="center">
<img src="https://github.com/user-attachments/assets/daac15de-b45b-4fef-9f90-ac6f548f402e" width="30%">
  <img src="https://github.com/user-attachments/assets/0f01ba8e-1033-45a8-b4ec-40841d7c8083" width="30%">
</p>

### 3. 찜 목록

사용자가 '좋아요'한 찜 목록을 확인할 수 있으며, 해당 목록은 지도와 함께 마커로 표시됩니다.

<p align="center">
<img src="https://github.com/user-attachments/assets/90de882b-b07a-48e2-bff0-793e4ab9fb47" width="40%">

### 4. 고객 지원

자유게시판에서 게시글 작성, 수정, 삭제가 가능하며, 댓글 작성, 수정, 삭제 기능도 제공합니다.

<p align="center">

<img src="https://github.com/user-attachments/assets/8f872cfc-8561-484d-a291-d2ddb2da407a" width="30%">
<img src="https://github.com/user-attachments/assets/3e7b92ad-fc8a-4d16-a0a9-2a2da9fdff34" width="30%">
<img src="https://github.com/user-attachments/assets/e77367a6-5d19-44b3-ad08-2ad36fc5db49" width="30%">
</p>

### 5. 여행 계획

사용자가 작성한 여행 계획을 지도에 마커로 표시하여 확인할 수 있으며, 계획을 수정 및 삭제할 수도 있습니다.


<p align="center">
  <img src="https://github.com/user-attachments/assets/22cc5cc2-7289-4426-bf43-8d27b1ee5272" width="30%">
  <img src="https://github.com/user-attachments/assets/2ec91a49-01c4-4fd8-a306-a39108aa7490" width="30%">
  <img src="https://github.com/user-attachments/assets/bd4f5306-d06f-4c66-9d98-4941497394e0" width="30%">
</p>


### 6. 상세 페이지

해당 지역에서 추천된 장소를 클릭하면, 장소에 대한 상세 페이지를 확인할 수 있습니다. 또한, 후기 및 별점을 남길 수 있습니다.

<p align="center">
<img src="https://github.com/user-attachments/assets/07f26b09-e8b1-4468-85f1-956d41107a6f" width="30%">
   
### 6. 숙소 검색

사용자가 지역을 검색하거나 클릭하면 해당 지역의 추천 숙소 목록이 나타나며, 숙소 클릭 시 예약 페이지로 이동합니다.

<p align="center">
<img src="https://github.com/user-attachments/assets/9011ed84-118c-4902-b7a6-3b7beeb3b962" width="30%">
<img src="https://github.com/user-attachments/assets/bc1a7f45-eec6-47c2-aca3-856468fbc1df" width="30%">
</p>

### 7. 길 찾기
   
출발지와 도착지를 입력하면 지도 상에 마커로 표시되며, 교통정보보기 버튼을 클릭하면 카카오맵으로 이동해 추가 정보를 볼 수 있습니다. 이때, 별도의 주소 재입력은 필요하지 않습니다.


<p align="center">
<img src="https://github.com/user-attachments/assets/a0b6ece6-3a05-47ca-ad55-4e0d0152ba41" width="30%">
<img src="https://github.com/user-attachments/assets/e636ab2a-dbbb-47cc-af08-52d7fdd23696" width="30%">
</p>

### 8. 여행 후기

 사용자들이 작성한 여행 후기가 무작위로 표시되며, 검색 기능을 통해 특정 지역의 후기만 볼 수 있습니다. 또한, 사용자는 여행 후기를 작성할 수 있습니다.
 
<p align="center">
<img src="https://github.com/user-attachments/assets/531f159c-5964-4c66-b159-c3cc9ad47e27" width="30%">
<img src="https://github.com/user-attachments/assets/c92e4ae5-a23d-4861-9e6b-3615cfaae643" width="30%">
</p>

## 코드 리뷰 📝

#### 0. 메인 페이지

##### VIEW - 체크박스 상태 변경
```
checkbox.checked = !checkbox.checked;

if (checkbox.checked) {
    button.classList.add('checked');
} else {
    button.classList.remove('checked');
}

```
여행할 지역을 클릭하면 해당 체크박스의 상태를 반전시키고 버튼 스타일을 변경.


##### 폼 유효성 검사
```
if (checkedCheckboxes === 0) {
    alert('여행할 지역을 선택해주세요.');
    return false;
}

if (checkedCheckboxes > maxSelections) {
    alert('하나의 지역만 선택할 수 있습니다.');
    return false;
}

```
사용자가 체크박스를 선택하지 않았거나, 선택한 체크박스의 수가 최대 선택 가능 수를 초과하는 경우 경고 메시지를 표시하고 폼 제출을 방지

##### Controller - 예)지도 상에서 경기도 클릭

```
@PostMapping("/gyeonggi")
public ModelAndView gyeonggi(@RequestParam(name = "gyeonggi", required = false) List<Integer> selectePlaces, HttpSession session) {
    ModelAndView mav = new ModelAndView();
    
    AccountsVO user = (AccountsVO) session.getAttribute("user");
    
    if (user == null) {
        mav.setViewName("redirect:/member/login");
        return mav;
    }
    
    int a_idx = user.getAccounts_idx();
    
    int sigunguCode1 = 0, sigunguCode2 = 0, sigunguCode3 = 0;

    if (selectePlaces != null && !selectePlaces.isEmpty()) {
        for (int i = 0; i < selectePlaces.size(); i++) {
            int place = selectePlaces.get(i);

            switch (i) {
                case 0: sigunguCode1 = place; break;
                case 1: sigunguCode2 = place; break;
                case 2: sigunguCode3 = place; break;
            }
        }
        ms.sel_sigunguCode(a_idx, sigunguCode1, sigunguCode2, sigunguCode3);
    }
    mav.setViewName("redirect:/duration");
    
    return mav;
}

```
선택된 장소의 코드인 sigunguCode1, sigunguCode2, sigunguCode3 변수를 0으로 초기화. 
선택된 장소가 null이 아니고 비어있지 않은 경우에 리스트에 있는 장소 코드를 반복하면서 각각의 코드 값을 변수에 할당 후 ms.sel_sigunguCode(a_idx, sigunguCode1, sigunguCode2, sigunguCode3)를 통해 선택 장소 코드들을 db에 저장한다. 이후 duration 페이지로 리다이렉트 해서 경기 장소에 대한 다음 단계로 이동하게 함.

#### 1. 회원가입 예외 처리


```
@PostMapping("/signUp")
public String signUp(AccountsVO input, RedirectAttributes redirectAttributes) {
    try {
        validateInput(input);
        ss.addAccount(input);
        return "redirect:/"; // 성공 시 메인 페이지로 리다이렉트

    } catch (NoSuchAlgorithmException e) {
        logger.error("비밀번호 해싱 처리 실패:", e);
        redirectAttributes.addFlashAttribute("errorMessage", "서버에서 문제가 발생했습니다. 다시 시도해 주세요.");
        return "redirect:/member/serverError"; 

    } catch (DuplicateUserException e) {
        logger.warn("중복된 사용자 정보: " + input.toString(), e);
        redirectAttributes.addFlashAttribute("errorMessage", e.getMessage());
        redirectAttributes.addFlashAttribute("duplicateFields", e.getFieldNames()); 
        return "redirect:/member/duplicateError"; 

    } catch (ValidationException e) {
        logger.warn("입력값이 유효하지 않음: " + input.toString(), e);
        redirectAttributes.addFlashAttribute("errorMessage", e.getMessage());
        return "redirect:/member/validateError"; 

    } catch (Exception e) {
        logger.error("Unexpected error occurred during signup", e);
        redirectAttributes.addFlashAttribute("errorMessage", "예기치 않은 오류가 발생했습니다. 다시 시도해 주세요.");
        return "redirect:/member/signupError"; 
    }
}

```
입력값 검증 및 예외 처리:
validateInput(input) 메서드를 통해 사용자 입력에 대한 유효성을 검사함으로써, 잘못된 데이터가 서비스로 넘어가지 않도록 예방하고 다양한 예외를 구체적으로 처리하여 각 상황에 맞는 에러 메시지를 사용자에게 전달함.

로깅 기능:
각 예외에 대해 적절한 로그를 남김으로써, 시스템의 상태를 모니터링할 수 있는 기회를 제공하여 문제 발생 시 디버깅을 용이하게 만듦.

RedirectAttributes 활용:
RedirectAttributes를 사용하여 일회성 데이터를 플래시 속성으로 전달함으로써 중복된 에러 메세지 전송을 피하고 페이지 간 정보를 안전하게 전달할 수 있음.

#### 2. 카테고리 별로(문화시설, 관광지, 레포츠, 숙박, 음식점 등) 해당 지역의 추천장소가 지도에 마커로 표시되어 추천
	
##### VIEW

```
<div class="custom-tab-menu">

                    <div class="custom-tab-row">
                        <a th:href="@{/recommendResult?(seldate=${seldate},type=0)}"><button class="custom-tab-link">전체</button></a>
                        <a th:href="@{/recommendResult?(seldate=${seldate},type=28)}"><button class="custom-tab-link">레포츠</button></a>
                    </div>

                    <div class="custom-tab-row">
                        <a th:href="@{/recommendResult?(seldate=${seldate},type=14)}"><button class="custom-tab-link">문화시설</button></a>
                        <a th:href="@{/recommendResult?(seldate=${seldate},type=32)}"><button class="custom-tab-link">숙박</button></a>
                    </div>
                    
                     <div class="custom-tab-row">
                        <a th:href="@{/recommendResult?(seldate=${seldate},type=12)}"><button class="custom-tab-link">관광지</button></a>
                        <a th:href="@{/recommendResult?(seldate=${seldate},type=39)}"><button class="custom-tab-link">음식점</button></a>
                    </div>
                </div>


```
TOUR API에 있는 데이터를 활용해서 각각의 카테고리별로 장소를 추천해 줌.

##### Service
```



```
##### DAO
```

```


#### 3.플러스 버튼을 동해 여행 계획에 추가 , 장소 이름 클릭 시 상세 페이지로 이동

##### Controller 
```
@GetMapping("planadd")
	public ModelAndView planaddpublic ModelAndView planadd(int p_idx, int a_idx, int areaCode, int sigunguCode1, 
                            int sel_idx, int duration, String seldate, int day) {

		// HTTP요청에서 전달되는 쿼리 파라미터를 받아온다.
	    ModelAndView mav = new ModelAndView();
	    int duration1 = duration /5;//총 기간을 5로 나눠서 저장
	    
	    TravelplanVO result = new TravelplanVO();//TravelplanVO객체를 생성해서 사용자가
	    //요청한 여행 계획 정보를 담을 준비를 한다.
	    
	    result.setA_idx(a_idx);
	    result.setAreaCode(areaCode);
	    result.setSigunguCode1(sigunguCode1);
	    result.setDuration(duration1);
	    result.setDay(day);
	    
	    //서비스계층의 planadd()메서드를 호출하여 여행계획을 db에 저장
	    //([p_idx,a_idx..)를 전달해서 새로운 여행 계획이 추가된다.
	    ts.planadd(p_idx,a_idx,areaCode,sigunguCode1,duration1,seldate,day);
	    //여행 계획이 추가된 후, 사용자를 recommendResult라는 경로로 리디렉션함
	    //redirect:/recommendResult라는 리디렉션 방식으로 페이지를 이동시키며,
	    //쿼리 파라미터로 seldate(선택날짜)와 type=0을 전달
	    //사용자가 선택한 날짜에 따른 추천 결과 페이지로 리디렉션함
	    mav.setViewName("redirect:/recommendResult?seldate="+seldate+"&type=0");
	    //리디렉션할 url이 설정된 상태에서 이 메서드가 종료되면, 브라우저는 해당 url로 이동
	    return mav;
	}	
```
##### Service 
```
	public int planadd(int p_idx, int a_idx, int areaCode, int sigunguCode1,
			int duration, String seldate,int day) {
		
		return dao.insert(p_idx,a_idx,areaCode,sigunguCode1,duration,seldate,day);
	}
```
##### DAO
```
@Insert("insert into travelplan(p_idx,a_idx,areaCode,sigunguCode1,duration,seldate,day) values(#{p_idx},#{a_idx},#{areaCode},#{sigunguCode1},#{duration},#{seldate},#{day})")
	int insert(@Param("p_idx") int p_idx, 
      @Param("a_idx") int a_idx, 
      @Param("areaCode") int areaCode, 
      @Param("sigunguCode1") int sigunguCode1,
      @Param("duration") int duration,
      @Param("seldate") String seldate,
      @Param("day") int day);
```

#### 4. 일정에 따른 장소 추가 후 여행 계획 버튼 클릭 시 사용자가 날짜별 추가한 장소 리스트 확인 가능

##### HTML
```
<div th:if="${Planplace.size() > 0}"><!-- 타임리프 조건문, 서버에서 받아온 여행 계획 리스트가 있는 경우에만 해당 내용 출력 -->
    <div class="tab-menu"><!-- 탭 메뉴 -->
        <!-- 탭 버튼 생성: 1부터 해당 여행 계획의 일수 만큼 버튼을 생성하는데 사용, ${i}는 현재 반복 인덱스-->
        <button th:each="i : ${#numbers.sequence(1, Planplace[0].duration)}" 
                th:text="'Day ' + ${i}"
                th:onclick="'openTab(event, \'tab' + ${i} + '\', '+ ${i} +', this.getAttribute(\'data-seldate\'))'"
                th:data-seldate="${Planplace[0].seldate}"
                class="tab-link">
        </button>
       
    </div>
```

##### Controller
```
	@GetMapping("travelplandetail")
	//1.메서드 선언
	//HTTP요청으로 seldate라는 파라미터를 받아온다. 현재 로그인한 사용자의 정보를 가져오기 위해 HttpSession객체를 받음
	public ModelAndView travelplandetail(@RequestParam("seldate")String seldate, HttpSession session) {
		//2.ModelAndView 객체 생성
		ModelAndView mav = new ModelAndView();
		//3.사용자 정보 가져오기
		AccountsVO user = (AccountsVO) session.getAttribute("user");
		int user_idx = user.getAccounts_idx();
		
		
		//4.여행 계획 데이터 가져오기
		mav.addObject("Planplace", ts.getPlanplace(user_idx,seldate));
		//TravelplanService의 getPlanplace() 메서드를 호출하여, 
		//특정 사용자의 특정 날짜(seldate)에 대한 여행 계획을 가져옴
		//user_idx와 seldate는 서비스 메서드에 전달되어 
		//데이터베이스에서 사용자의 해당 날짜에 맞는 여행 계획 데이터를 가져옴.
		//이 메서드에서 가져온 여행 계획 데이터는 Planplace라는 이름으로 모델에 추가
		return mav;
	}

```
traveldetail 메서드가 호출되면, 사용자가 선택한 날짜(seldate)를 파라미터로 받고, 세션에서 로그인한 사용자의 정보를 가져옴
사용자의 고유 ID(user_idx)와 선택한 날짜를 이용해 TravelplanService의 getPlanplace() 메서드를 호출하여 해당 날짜에 맞는 여행 계획 데이터를 가져옴.
가져온 데이터를 Planplace라는 이름으로 ModelAndView 객체에 추가하고, 이 데이터를 사용해 여행 계획 상세 정보를 화면에 출력할 수 있도록 뷰로 전달

##### Service
```
public List<PlaceVO> getPlanplace(int user_idx, String seldate) {

		return dao.getPlanplace(user_idx,seldate);
	}
```
user 고유 번호와 user가 선택한 날짜를 파라미터로 받아서 getPlanPlace로 넘겨준다.

##### DAO
```
@Select("select * from place_a_idx where a_idx = #{user_idx} and seldate = #{seldate}")
	List<PlaceVO> getPlanplace(@Param("user_idx") int user_idx, @Param("seldate") String seldate);
```
컨트롤러에서 가져온 user_idx와 선택한 날짜(seldate)에 맞는 여행 계획을 데이터베이스에서 찾아서 그 정보를 가져온 후 PlaceVO 객체로 여러 개 담아 리스트 형식으로 반환함.


### 5. 특정 장소에 대한 상세 정보를 확인.

##### 5-1. 사용자 인증 확인
```
if (user == null) {
    mav.setViewName("redirect:/member/login");
    return mav;
}
```
##### 5-2.장소 정보 가져오기
```
HashMap<String, String> place = ts.getPlace(contenttypeid, contentid);
mav.addObject("place", place);

HashMap<String, String> placeDetails = ts.getPlaceDetails(contenttypeid, contentid);
mav.addObject("detail", placeDetails);
```
사용자가 요청한 장소에 대한 정보를 ts 서비스를 통해 가져옵니다. 이 정보는 페이지에 표시될 내용입니다.


##### 5-3. 리뷰 데이터 추가
```
mav.addObject("reviews", rs.getReviewsByPlaceId(idx)); // 리뷰 데이터 추가
장소에 대한 리뷰 데이터를 추가하여 사용자가 다른 사람들의 의견을 볼 수 있도록 합니다.
```
##### 5-4. 좋아요 상태 확인
```
PlaceVO isLiked = ds.isLikedByUser(user.getAccounts_idx(), idx);
int islike;
if (isLiked == null) {
    islike = 0;
} else {
    islike = isLiked.getIslike();
}

mav.addObject("isLiked", islike);

```
사용자가 해당 장소를 좋아요 했는지 여부를 확인하고, 그 상태를 모델에 추가

#### 6.게시판 CRUD

##### CREATE (생성)
```
// Q&A 글쓰기
@PostMapping("/cswrite")
public String cswrite(CustomerVO input) {
    cs.cusWrite(input); // 고객 서비스에 새로운 Q&A 게시글 추가
    return "redirect:/member/customer"; // 목록으로 리다이렉트
}
```
##### Read (읽기)
```
@GetMapping("/customer")
public ModelAndView csboard(@RequestParam(value = "idx", required = false) Integer idx) {
    ModelAndView mav = new ModelAndView();
    
    Map<String, Object> announceMap = as.announce(idx);
    mav.addObject("pg", announceMap.get("pg"));
    mav.addObject("announce", announceMap.get("list"));
    
    Map<String, Object> qnaMap = cs.cstest(idx);
    mav.addObject("qnapg", qnaMap.get("qnapg"));
    mav.addObject("qna", qnaMap.get("list"));
    
    return mav; // 공지사항과 Q&A 목록 반환
}

```

##### Q&A 게시글 보기

```
@GetMapping("/csView/{board_idx}")
public ModelAndView csview(@PathVariable("board_idx") int idx) {
    ModelAndView mav = new ModelAndView();
    
    mav.addObject("row", cs.getCsBoardOne(idx)); // 게시글 정보
    mav.addObject("replys", rs.getReplys(idx)); // 댓글 정보
    mav.setViewName("member/csView");
    
    return mav; // 게시글 상세 정보 반환
}

```
##### Update (수정) Q&A 게시글 수정

```
@PostMapping("/csUpdate/{board_idx}")
public String update(CustomerVO input) {
    cs.update(input); // Q&A 게시글 수정
    return "redirect:/member/customer#qna"; // 목록으로 리다이렉트
}

```
##### 댓글 수정
```
@PostMapping("/repUpdate")
public String repUpdate(ReplyVO input) {
    rs.updateReply(input); // 댓글 수정
    return "redirect:/member/csView/" + input.getC_idx(); // 게시글 상세로 리다이렉트
}
```
##### Delete (삭제)
##### Q&A 게시글 삭제
```
@GetMapping("/csdelete/{board_idx}")
public String csdelete(CustomerVO idx) {
    cs.deleteCS(idx); // Q&A 게시글 삭제
    return "redirect:/member/customer#qna"; // 목록으로 리다이렉트
}

```
##### 댓글 삭제
```
@GetMapping("/csView/delete")
public String repdelete(@RequestParam(value = "rep_idx", required = false) Integer rep_idx, 
                        @RequestParam(value = "c_idx", required = false) Integer c_idx) {
    rs.deleteRep(rep_idx); // 댓글 삭제
    return "redirect:/member/csView/" + c_idx; // 게시글 상세로 리다이렉트
}

```

### 7. 찜 목록 
장소 별 상세 페이지에서 우측 상단의 하트를 클릭하면, 찜 목록에서 지도에 마커로 표시된 정보를 확인할 수 있음(삭제 가능)

##### HTML - 마커 추가 및 토글 기능

```
function toggleMarker(check, x, y) {
    var key = x + ',' + y; // 키를 x, y 좌표로 설정
    var locationItem = check.closest('.location-item');

    if (check.checked) {
        // 체크된 경우 마커 추가
        var marker = new kakao.maps.Marker({
            position: new kakao.maps.LatLng(y, x),
            map: map // 현재 지도에 마커 추가
        });
        markers[key] = marker; // 마커를 markers 객체에 저장
        addMarkerClickEvent(marker, key, locationItem); // 마커 클릭 이벤트 추가
        locationItem.classList.add('selected'); // 선택된 항목 스타일 변경
    } else {
        // 체크 해제된 경우 마커 제거
        if (markers[key]) {
            markers[key].setMap(null); // 지도에서 마커 제거
            delete markers[key]; // markers 객체에서 삭제
        }
        if (overlays[key]) {
            overlays[key].setMap(null); // 오버레이 제거
            delete overlays[key]; // overlays 객체에서 삭제
        }
        locationItem.classList.remove('selected'); // 선택 해제 시 스타일 변경
    }
}
```

##### Controller - 사용자가 특정 장소에 좋아요 추가하는 기능
```
@PostMapping("/member/like")
public ResponseEntity<String> likePlace(@RequestBody LikeVO likeVO) {
    try {
        // 장소 ID와 사용자 ID를 가져와 좋아요 추가
        int idx = likeVO.getP_idx();
        like.likeupdate(idx, likeVO.getA_idx());
        like.insertLike(likeVO);
        return ResponseEntity.ok("Liked"); // 성공 시 응답
    } catch (Exception e) {
        e.printStackTrace();  // 오류 로그 출력
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                             .body("Error occurred while liking place.");
    }
}

```


##### DAO - 사용자가 좋아하는 장소에 대한 정보를 like_place 테이블에 추가하는 기능을 구현
```
@Insert("INSERT INTO like_place (a_idx, title, addr1, firstimage, mapx, mapy, p_idx, contenttypeid, contentid) " +
       "VALUES (#{a_idx}, #{title}, #{addr1}, #{firstimage}, #{mapx}, #{mapy}, #{p_idx}, #{contenttypeid}, #{contentid})")
void insert(LikeVO likeVO);
```

### 8. 여행 계획

```
public String[] updateImages(MultipartFile[] images, TraverserStoryVO story) {
    String[] imagePaths = new String[10];
    String uploadDir = "C:/spring/traverse/www/src/main/resources/static/story/";

    for (int i = 0; i < images.length && i < 10; i++) {
        MultipartFile image = images[i];
        if (!image.isEmpty()) {
            String fileName = UUID.randomUUID().toString() + "_" + image.getOriginalFilename();
            File file = new File(uploadDir, fileName);
            try {
                image.transferTo(file);
                imagePaths[i] = fileName;
            } catch (IOException e) {
                e.printStackTrace();
            }
        } else {
            // 기존 이미지를 유지
            imagePaths[i] = story.getImge1(); // 예시로 첫 번째 이미지를 가져옴
        }
    }
    return imagePaths;
}

```

다중 파일 업로드를 가능하게 함:

메서드는 MultipartFile[] images를 매개변수로 받아 여러 파일을 한 번에 처리할 수 있도록 설계됨으로써, 사용자가 여러 이미지를 동시에 업로드할 수 있는 편리함을 제공함.

고유한 파일명 생성을 통해 충돌을 방지함:

UUID.randomUUID().toString()을 사용하여 각 파일에 대해 고유한 이름을 생성함으로써, 파일명 충돌을 방지하고 서버의 데이터 무결성을 유지함.

기존 이미지를 유지함으로써 사용자 경험을 개선함:

사용자가 업로드한 파일이 비어 있을 경우 기존 이미지를 그대로 유지하도록 로직을 구성함으로써, 불필요한 데이터 손실을 방지하고 사용자 경험을 향상시킴.

예외 처리를 통해 안정성을 높임:

try-catch 블록을 통해 파일 전송 중 발생할 수 있는 IOException을 처리함으로써, 코드의 안정성을 증가시킴.

배열을 통한 결과 반환으로 쉽게 처리할 수 있도록 함:

메서드는 배열 imagePaths를 사용하여 모든 이미지 경로를 반환함으로써, 호출 측에서 여러 이미지를 쉽게 관리하고 처리할 수 있도록 도움.

### 9. ApiService

외부 API로부터 데이터를 JSON 형식으로 가져오고, 이를 파싱하여 ApiVO 객체로 변환한 뒤 데이터베이스에 저장하는 프로세스를 처리

#### 1)기본 url 설정

```
String url = "https://apis.data.go.kr/B551011/KorService1/areaBasedList1?";
```

API 요청을 보낼 기본 URL로, 이 URL에 추가적인 파라미터들을 붙여서 최종 API 요청 URL을 만듦

#### 2)파라미터 설정

```
HashMap<String, String> params = new HashMap<>();
params.put("ServiceKey", "6RkKaXlTQt2IajvJnERjyEHx6pTvNp0n8ZT/iBQPLe4bXmMbm0o8mBSubhyyCBEjYC0Ur+OsD/pNUdrxNp7owQ==");
params.put("numOfRows", "800");
params.put("pageNo", "21");
params.put("numOfRows", "1000");
params.put("pageNo", "17");
params.put("MobileOS", "ETC");
params.put("MobileApp", "AppTest");
params.put("listYN", "Y");
params.put("arrange", "A");
params.put("contentTypeId", "39");
params.put("_type", "json");
```

요청에 필요한 파라미터들을 HashMap에 저장.
ServiceKey: API 호출에 필요한 인증키.
numOfRows, pageNo: 한 페이지에 보여줄 항목의 수와 페이지 번호.
MobileOS, MobileApp: 모바일 환경 및 앱 이름을 나타내는 값.
listYN: 리스트 표시 여부.
arrange: 정렬 방식.
contentTypeId: 특정 카테고리(여기서는 음식점)의 콘텐츠를 나타내는 값.
_type: 응답 데이터를 JSON 형식으로 요청.

#### 3)파라미터 URL 인코딩 및 URL 생성

```
for(String key : params.keySet()) {
   String value = params.get(key);
   value = URLEncoder.encode(value, "UTF-8");
   url += String.format("%s=%s&", key, value);
}
```

파라미터 값들을 UTF-8로 인코딩하여 안전한 URL로 변환.
url에 파라미터들을 key=value 형식으로 추가.

#### 4)HTTP 연결 설정 및 요청
```
HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();
int responseCode = conn.getResponseCode();
System.out.println(responseCode);
```

HttpURLConnection을 통해 API에 GET 요청을 보냄.
conn.getResponseCode()는 서버에서 응답하는 HTTP 상태 코드를 반환. 여기서 200은 요청이 성공했음을 의미

#### 5) 응답 데이터 수신
```
if (responseCode == 200) {
   Scanner sc = new Scanner(conn.getInputStream());
   while (sc.hasNextLine()) {
      data += sc.nextLine() + "\n";
   }
   sc.close();
   System.out.println(data);
}
```
서버가 200 응답을 보낸 경우, Scanner를 사용해 응답 바디 데이터를 읽어오고, 읽어온 데이터를 문자열로 변환하여 data에 저장

#### 6) JSON 파싱 및 데이터 매핑
```
JsonMapper jsonMapper = JsonMapper.builder()
                                  .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false)
                                  .build();
JsonNode jsonNode = jsonMapper.readTree(data).get("response").get("body").get("items").get("item");
return jsonMapper.readValue(jsonNode.toString(), new TypeReference<List<ApiVO>>() {});
```

JsonMapper: Jackson 라이브러리를 사용하여 JSON 데이터를 처리하는 객체.
DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES를 false로 설정하여, 정의되지 않은 속성이 있어도 오류를 발생시키지 않고 무시.
readTree: 응답받은 JSON 데이터를 파싱하여 JsonNode 트리 구조로 변환.
jsonNode는 JSON 데이터에서 response.body.items.item 노드에 접근.
readValue: jsonNode를 List<ApiVO>로 변환 후,TypeReference를 사용하여 제네릭 타입인 List<ApiVO>에 JSON 데이터를 매핑.

## ERD Diagram 📦

<p align="center">
<img src="https://github.com/user-attachments/assets/a352a8b6-542f-4161-ae84-43118944ef09" width="60%">
</p>

#### 1. accounts 테이블
기본 키: accounts_idx
accounts_idx 사용자마다 고유한 식별자 값이 부여되며, 유저가 중복 없이 관리된다.
외래 키 없음
이유: accounts 테이블은 사용자 계정 정보를 관리하는 테이블로, 다른 테이블에 연결되기 위한 중심 테이블이기 때문에 외래 키는 없고 다른 테이블에서 참조.


#### 2. customer_board 테이블
기본 키: board_idx
board_idx는 각 게시물을 고유하게 식별하는 기본 키이며 각 게시물은 고유 ID로 식별됨.
외래 키: accounts_idx
accounts_idx는 accounts 테이블의 기본 키를 참조하는 외래 키이며 게시물을 작성한 사용자와 연결되며, 게시물이 어떤 사용자의 것인지 관계를 나타냄.
이유: 게시물(customer_board)은 작성한 사용자(accounts)와 연결되어야 하므로 accounts 테이블의 기본 키를 참조하게 설정됨. 이를 통해 사용자가 작성한 게시물을 쉽게 조회할 수 있음.


#### 3. reply 테이블
기본 키: rep_idx
rep_idx는 각 댓글을 고유하게 식별하는 기본 키이며 각 댓글은 고유한 식별자가 있어야 함.
외래 키: a_idx, c_idx
a_idx는 accounts 테이블의 기본 키를 참조하여 댓글을 작성한 사용자와 연결됨.
c_idx는 customer_board 테이블의 기본 키를 참조하여 댓글이 달린 게시물과 연결됨.
이유: 댓글은 반드시 특정 사용자(accounts)와 특정 게시물(customer_board)에 속해야 하므로 두 테이블의 외래 키를 설정함.


#### 4. announcement 테이블
기본 키: announcement_idx
announcement_idx는 공지사항을 고유하게 식별하는 기본 키. 각 공지사항은 고유한 식별자 값을 가짐.
외래 키 없음
이유: 공지사항 테이블은 공지사항 자체만을 관리하는 테이블로, 별도의 외래 키가 필요 없음.


#### 5. like_place 테이블
기본 키: like_idx
like_idx는 각 좋아요를 고유하게 식별하는 기본 키.
외래 키: a_idx, p_idx
a_idx는 accounts 테이블의 기본 키를 참조하여 좋아요를 누른 사용자를 나타냄.
p_idx는 place 테이블의 기본 키를 참조하여 좋아요를 누른 장소를 나타냄.
이유: 좋아요는 사용자(accounts)와 장소(place)에 속하는 기능이므로, 각각의 외래 키를 설정하여 사용자가 어떤 장소에 좋아요를 눌렀는지 알 수 있도록 설계함.


#### 6. place 테이블
기본 키: idx
idx는 장소를 고유하게 식별하는 기본 키.
외래 키 없음
이유: 장소 테이블은 각 장소의 정보를 관리하는 독립된 테이블이므로 외래 키 참조는 없음.

#### 7. dep_reply 테이블
기본 키: drep_idx
drep_idx는 각 답글(댓글에 달린 댓글)을 고유하게 식별하는 기본 키.
외래 키: a_idx, p_idx
a_idx는 accounts 테이블을 참조하여 답글을 작성한 사용자를 나타냄.
p_idx는 place 테이블을 참조하여 답글이 달린 장소를 나타냄.
이유: 답글은 사용자와 특정 장소와 관련이 있으므로, 각각의 외래 키를 통해 관계 정의.


#### 8. sel_place 테이블
기본 키: sel_idx
sel_idx는 선택된 장소를 고유하게 식별하는 기본 키.
외래 키: a_idx
a_idx는 accounts 테이블의 기본 키를 참조하여 장소를 선택한 사용자를 나타냄.
이유: 선택된 장소는 특정 사용자에 의해 결정되므로, 사용자 정보를 참조하기 위해 외래 키 사용.


#### 9. Travelreview 테이블
기본 키: idx
idx는 여행 리뷰를 고유하게 식별하는 기본 키.
외래 키: a_idx
a_idx는 accounts 테이블의 기본 키를 참조하여 여행 리뷰를 작성한 사용자를 나타냄.
이유: 여행 리뷰는 사용자와 연관되므로, 리뷰 작성자를 나타내기 위해 외래 키 사용.


#### 10. travelplan 테이블
기본 키: idx
idx는 여행 계획을 고유하게 식별하는 기본 키.
외래 키: a_idx, p_idx
a_idx는 accounts 테이블의 기본 키를 참조하여 여행 계획을 작성한 사용자를 나타냄.
p_idx는 place 테이블의 기본 키를 참조하여 계획된 여행 장소를 나타냄.
이유: 여행 계획은 사용자와 장소에 연결되므로, 이를 나타내기 위해 두 테이블의 외래 키를 사용함.


#### 11. sigungu 테이블
기본 키: sigunguCode
sigunguCode는 행정 구역(시군구)을 고유하게 식별하는 기본 키.
외래 키 없음
이유: 이 독립된 행정 구역 정보를 저장하는 테이블이기 때문에 다른 테이블과의 관계가 필요 없음.


#### 12. area 테이블
기본 키: areaCode
areaCode는 지역을 고유하게 식별하는 기본 키.
외래 키 없음
이유: 지역 정보를 관리하는 독립 테이블로 외부 참조가 필요하지 않음


